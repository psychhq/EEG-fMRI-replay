# SCRIPT INFORMATION:
# SCRIPT: DETECT NEURAL SEQUENCES IN TASK BY MODELLING
# PROJECT: FMRIREPLAY
# WRITTEN BY LENNART WITTKUHN, 2018 - 2019
# REVISED BY QI HUANG 2022
# CONTACT: STATE KEY LABORATORY OF COGNITIVE NEUROSCIENCE AND LEARNING, BEIJING NORMAL UNIVERSITY


## Decoding on slow trials

### Initialization

We load the data and relevant functions:

```{r, warning=FALSE, message=FALSE, echo=TRUE}
# find the path to the root of this project:
setwd('/home/huangqi/Data/fmrireplay')
path_root = getwd()
source(file.path(path_root, 'code', '7decoding_task_rest', "fmrireplay-analysis-source.R"))
path_figures <- file.path(path_root, 'derivatives', 'decoding', "Nico_method")
path_sourcedata <- file.path(path_root, 'sourcedata', 'Nico_method')
# create a list of participants to exclude based on behavioral performance:
sub_excludes <- c("sub-01", "sub-03", "sub-05", "sub-06", "sub-10",
                  "sub-12", "sub-14", "sub-16", "sub-17",
                  "sub-22", "sub-23", "sub-29", "sub-35",
                  "sub-37", "sub-39", "sub-43", "sub-46")
sub_exclude <- c(1, 3, 5, 6, 10, 12, 14, 16, 17, 22, 23, 29, 35, 37, 39, 43, 46)
color_events <- rev(hcl.colors(5, "Zissou 1"))
```

load the packages

```{r}
# 'emmeans' is not support by linux

packages = c("plyr", 'dplyr', 'ggplot2', "assertr", "data.table",
             'lemon', 'lmerTest', 'ggpubr', "rstatix", "broom",
             'forcats', 'nloptr', 'cowplot', 'viridis', 'data.table',
             'stringr')
load_packages(packages_list = packages)

```

load the data files

```{r,echo=True}

dt_VFL <- read.csv(file.path(
  path_root, 'derivatives', 'decoding', 'VFL_decoding', 'VFL_decoding.csv'), sep = ",", as.is = TRUE, stringsAsFactors = FALSE, header = TRUE)
dt_replay <- read.csv(file.path(path_root, 'derivatives', 'decoding', 'task_decoding', 'replay_decoding.csv'), sep = ",", as.is = TRUE, stringsAsFactors = FALSE, header = TRUE)
dt_VFL$marker <- NaN
dt_prob <- rbind(dt_VFL, dt_replay)
replay_sequences <- read.csv(file.path(path_root, 'sourcedata', 'sequence.csv'), sep = ",")

```


We prepare event and decoding data of sequence trials:

```{r}
# functions for different periods
get_period = function(trs_in) {
  if (length(trs_in) == 8) {
    first = trs_in[c(1, 2, 3, 4, 5)]
    second = trs_in[c(6, 7, 8)]
    return(list(first = first, second = second))
  } }

# create a subset of the events data table only including sequence task events:
dt_replay_event = dt_prob %>% filter(test_set == "test-rep_long")

# create a subset of the decoding data only including the sequence task data:
dt_replay_seq_fwd = dt_replay_event %>%
  filter(test_set == "test-rep_long" &
           class != "other"
           &
           mask == "union" &
           marker == 51) %>%
  setDT(.)

dt_replay_seq_bwd = dt_replay_event %>%
  filter(test_set == "test-rep_long" &
           class != "other"
           &
           mask == "union" &
           marker == 52) %>%
  setDT(.)

dt_replay_seq_list = list(dt_replay_seq_fwd, dt_replay_seq_bwd)

```

### Probability time courses

```{r}
# dt_replay_seq = dt_replay_seq_fwd
for (dt_replay_seq in dt_replay_seq_list) {
  # define the condition
  if (dt_replay_seq$marker[1] == 51) { condition = 'fwd'
  } else if (dt_replay_seq$marker[1] == 52) { condition = 'bwd' }

  for (period in c("first", "second")) {
    trs_zone = get_period(c(1, 2, 3, 4, 5, 6, 7, 8))[[period]]
    dt_replay_seq$periods[
      dt_replay_seq$seq_tr %in% trs_zone] = period
  }
  # assign the excluded label to all trs that are not in the forward or backward period:
  dt_replay_seq$periods[is.na(dt_replay_seq$periods)] = "excluded"

  library(data.table)
  dt_replay_seq <- setDT(dt_replay_seq)
  # probabilities are normalized for each class within a trial to sum up to 1
  # normalized within trial and between several seq_tr ###
  dt_replay_seq = dt_replay_seq %>%
    setDT(.) %>%
    .[, by = .(participant, classifier, run, trials), ":="(
      probability_norm = probability / sum(probability),
      probability_zscore = (probability - mean(probability)) / sd(probability),
      probability_cum = cumsum(probability) / max(cumsum(probability)))]

  # order sequence trial data by participant, classifier, trial and serial TR:
  dt_replay_seq = setorder(dt_replay_seq, participant, classifier, run, trials, seq_tr) %>% setDT(.)


  # select the variable of interest:
  variable = "probability_norm"
  dt_replay_seq$class_label = 0
  dt_replay_seq[dt_replay_seq$class == 'girl']$class_label = 1
  dt_replay_seq[dt_replay_seq$class == 'scissors']$class_label = 2
  dt_replay_seq[dt_replay_seq$class == 'zebra']$class_label = 3
  dt_replay_seq[dt_replay_seq$class == 'banana']$class_label = 4

  dt_replay_seq %>%
    verify(class_label != 0)

  # filter excluded subjects in replay sequences
  replay_sequences = replay_sequences %>%
    filter(!subject %in% sub_excludes) %>%
    verify(length(unique(subject)) == 33) %>%
    setDT(.)

  # set the sequence position for each subject and each mental simulation condition
  dt_replay_seq$position = 0
  for (participants in unique(dt_replay_seq$participant)) {
    dt_replay_seq[dt_replay_seq$participant == participants & dt_replay_seq$marker == 51]$position =
      match(dt_replay_seq[dt_replay_seq$participant == participants & dt_replay_seq$marker == 51]$class_label,
            replay_sequences[subject == paste0('sub-', str_pad(participants, 2, side = "left", pad = "0")), 2:5])
    dt_replay_seq[dt_replay_seq$participant == participants & dt_replay_seq$marker == 52]$position = (5 -
      match(dt_replay_seq[dt_replay_seq$participant == participants & dt_replay_seq$marker == 52]$class_label,
            replay_sequences[subject == paste0('sub-', str_pad(participants, 2, side = "left", pad = "0")), 2:5]))
  }

  dt_replay_seq_prob = dt_replay_seq %>%
    # average across trials separately each position, TR, and participant
    .[, by = .(participant, seq_tr, position, periods), .(
      num_trials = .N,
      mean_prob = mean(get('probability')) * 100
    )] %>%
    # average across participants and calculate standard error of the mean:
    .[, by = .(seq_tr, position, periods), .(
      num_subs = .N,
      mean_prob = mean(mean_prob),
      sem_upper = mean(mean_prob) + (sd(mean_prob) / sqrt(.N)),
      sem_lower = mean(mean_prob) - (sd(mean_prob) / sqrt(.N))
    )] %>%
    # check if averaged data is consistent with expected number of participants:
    verify(all(num_subs == 33)) %>%
    # create a new variable that expresses TRs as time from stimulus onset:
    mutate(time = (seq_tr - 1) * 1.3) %>%
    setDT(.)

  # We compare the mean indices of association (regression slope, correlation, mean serial position) for every TR:

  # select positions within every TR that should be selected:
  pos_sel = seq(1, 4)
  # define relevant variables:
  variable = "probability_norm"
  cor_method = "kendall"
  # calculate indices of association at every TR:
  dt_replay_seq_cor = dt_replay_seq %>%
    filter(position %in% seq(1, 4, by = 1)) %>%
    setDT(.) %>%
    .[, by = .(participant, run, trials, periods, seq_tr), {
      # order the probabilities in decreasing order (first = highest):
      prob_order_idx = order(get(variable), decreasing = TRUE)
      # order the positions by probability:
      pos_order = position[prob_order_idx]
      # order the probabilities:
      prob_order = get(variable)[prob_order_idx]
      # select positions
      pos_order_sel = pos_order[pos_sel]
      prob_order_sel = prob_order[pos_sel]
      list(
        # calculate the number of events:
        num_events = length(pos_order_sel[!is.na(pos_order_sel)]),
        # calculate the mean step size between probability-ordered events:
        mean_step = mean(diff(pos_order_sel)),
        # calculate the mean correlation between positions and their probabilities:
        cor = cor.test(pos_order_sel, prob_order_sel, method = cor_method)$estimate,
        # calculate the slope of a linear regression between position and probabilities:
        slope = coef(lm(prob_order_sel ~ pos_order_sel))[2]
        # verify that the number of events matches selection and correlations -1 < r < 1
      ) }] %>%
    verify(all(num_events == length(pos_sel))) %>%
    # average across trials for each participant (flip values by multiplying with -1):
    .[, by = .(participant, periods, seq_tr), .(
      num_trials = .N,
      mean_cor = mean(cor) * (-1),
      mean_step = mean(mean_step),
      mean_slope = mean(slope) * (-1)
    )] %>%
    # shorten the period name:
    mutate(period_short = ifelse(periods == "first", "1st", periods)) %>%
    transform(period_short = ifelse(periods == "second", "2nd", period_short)) %>%
    mutate(color = ifelse(period_short == "first", "dodgerblue", "red")) %>%
    setDT(.)

  # We compare the mean indices of association (regression slope, correlation,
  # mean serial position) against zero (the expectation of no association)
  # for every TR:
  seq_test_time <- function(data, variable) {
    data_out = data %>%
      # average across participants for every speed at every TR:
      # check if the number of participants matches:
      .[, by = .(periods, seq_tr), {
        # perform a two-sided one-sample t-test against zero (baseline):
        ttest_results = t.test(get(variable), alternative = "two.sided", mu = 0);
        list(
          num_subs = .N,
          mean_variable = mean(get(variable)),
          sd_variable = sd(get(variable)),
          pvalue = ttest_results$p.value,
          tvalue = ttest_results$statistic,
          df = ttest_results$parameter,
          cohens_d = round(abs(mean(mean(get(variable)) - 0) / sd(get(variable))), 2),
          sem_upper = mean(get(variable)) + (sd(get(variable)) / sqrt(.N)),
          sem_lower = mean(get(variable)) - (sd(get(variable)) / sqrt(.N))
        ) }] %>%
      verify(all(num_subs == 33)) %>%
      verify(all((num_subs - df) == 1)) %>%
      # adjust p-values for multiple comparisons (filter for forward and backward period):
      # check if the number of comparisons matches expectations:
      .[period %in% c("first", "second"), ":="(
        num_comp = .N,
        pvalue_adjust = p.adjust(pvalue, method = "fdr", n = .N)
      )] %>%
      # round the original p-values according to the apa standard:
      mutate(pvalue_round = round_pvalues(pvalue)) %>%
      # round the adjusted p-value:
      mutate(pvalue_adjust_round = round_pvalues(pvalue_adjust)) %>%
      # sort data table:
      setorder(., periods, seq_tr) %>%
      # create new variable indicating significance below 0.05
      mutate(significance = ifelse(pvalue_adjust < 0.05, "*", ""))
    return(data_out)
  }

  # filter for significant p-values to make reporting easier:
  replay_mean_slope = seq_test_time(data = dt_replay_seq_cor, variable = "mean_slope")
  rmarkdown::paged_table(seq_test_time(data = dt_replay_seq_cor, variable = "mean_slope"))


  #### Figure 3b
  plot_seq_cor_time = function(dt, variable) {
    plot = ggplot(data = dt, mapping = aes(
      x = seq_tr, y = mean_variable)) +
      geom_hline(aes(yintercept = 0), linetype = "solid", color = "gray") +
      geom_ribbon(aes(ymin = sem_lower, ymax = sem_upper), alpha = 0.5,
                  fill = 'dodgerblue') +
      geom_line() +
      xlab("Time from sequence onset (TRs)") +
      ylab("Regression slope") +
      scale_colour_viridis(name = "Speed (ms)", discrete = TRUE, option = "cividis") +
      scale_fill_viridis(name = "Speed (ms)", discrete = TRUE, option = "cividis") +
      scale_x_continuous(labels = label_fill(seq(1, 8, 1), mod = 1), breaks = seq(1, 8, 1)) +
      guides(color = guide_legend(nrow = 1)) +
      annotate("text", x = 1, y = -0.2 * 0.1, label = "1 TR = 1.3 s",
               hjust = 0, size = rel(3)) +
      coord_capped_cart(expand = TRUE, ylim = c(-0.2 * 0.1, 0.2 * 0.1)) +
      theme(panel.border = element_blank(), axis.line = element_line()) +
      theme(axis.line = element_line(colour = "black"),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            panel.border = element_blank(),
            panel.background = element_blank()) +
      theme(legend.position = "top", legend.direction = "horizontal",
            legend.justification = "center", legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
            legend.box.margin = margin(t = 0, r = 0, b = 0, l = 0)) +
      geom_segment(aes(x = 0.05, xend = 0.05, y = 0.01 * 0.1, yend = 0.2 * 0.1),
                   arrow = arrow(length = unit(5, "pt")), color = "darkgray") +
      geom_segment(aes(x = 0.05, xend = 0.05, y = -0.01 * 0.1, yend = -0.2 * 0.1),
                   arrow = arrow(length = unit(5, "pt")), color = "darkgray") +
      annotate(geom = "text", x = 0.4, y = 0.2 * 0.1, label = "Forward order",
               color = "darkgray", angle = 90, size = 3) +
      annotate(geom = "text", x = 0.4, y = -0.2 * 0.1, label = "Backward order",
               color = "darkgray", angle = 90, size = 3)
    return(plot)
  }

  # plot the Figure 3b
  fig_seq_slope_time = plot_seq_cor_time(dt = subset(
    seq_test_time(data = dt_replay_seq_cor, variable = "mean_slope")), variable = "mean_slope")

  fig_seq_slope_time;

  # save the plot figure and file
  ggsave(filename = sprintf("fmrireplay_plot_decoding_sequence_timecourses_slopes_%s.pdf", condition),
         plot = fig_seq_slope_time, device = cairo_pdf, path = path_figures, scale = 1,
         dpi = "retina", width = 5, height = 4)
  subset(seq_test_time(data = dt_replay_seq_cor, variable = "mean_slope")) %>%
    write.csv(., file = file.path(path_sourcedata, sprintf("source_data_figure_3b_%s.csv", condition)),
              row.names = FALSE)


  ### Regression slope means (Figure 3c)
  seq_test_period <- function(data, variable) {
    data_out = data %>%
      # filter out the excluded time period (select only forward and backward period):
      filter(periods != "excluded") %>%
      setDT(.) %>%
      # average for each time period and speed condition for every participant:
      .[, by = .(participant, periods), .(
        mean_variable = mean(get(variable)))] %>%
      # average across participants for every speed at every TR:
      # check if the number of participants matches:
      .[, by = .(periods), {
        # perform a two-sided one-sample t-test against zero (baseline):
        ttest_results = t.test(mean_variable, alternative = "two.sided", mu = 0);
        list(
          num_subs = .N,
          mean_variable = mean(mean_variable),
          sd_variable = sd(mean_variable),
          pvalue = ttest_results$p.value,
          tvalue = round(abs(ttest_results$statistic), 2),
          df = ttest_results$parameter,
          cohens_d = abs(round((mean(mean_variable) - 0) / sd(mean_variable), 2)),
          sem_upper = mean(mean_variable) + (sd(mean_variable) / sqrt(.N)),
          sem_lower = mean(mean_variable) - (sd(mean_variable) / sqrt(.N))
        )
      }] %>%
      verify(all(num_subs == 33)) %>%
      verify(all((num_subs - df) == 1)) %>%
      # adjust p-values for multiple comparisons:
      # check if the number of comparisons matches expectations:
      .[periods %in% c("first", "second"), ":="(
        num_comp = .N,
        pvalue_adjust = p.adjust(pvalue, method = "fdr", n = .N)
      )] %>%
      verify(num_comp == 2) %>%
      # add variable that indicates significance with stupid significance stars:
      mutate(significance = ifelse(pvalue < 0.05, "*", "")) %>%
      # round the original p-values according to APA manual:
      mutate(pvalue_round = round_pvalues(pvalue)) %>%
      # round the adjusted p-value:
      mutate(pvalue_adjust_round = round_pvalues(pvalue_adjust)) %>%
      # sort data table:
      setorder(periods) %>%
      # shorten the period name:
      mutate(period_short = ifelse(periods == "first", "1st", periods)) %>%
      transform(period_short = ifelse(periods == "second", "2nd", period_short)) %>%
      mutate(color = ifelse(period_short == "fwd", "dodgerblue", "red")) %>%
      setDT(.)
    return(data_out)
  }

  rmarkdown::paged_table(seq_test_period(data = dt_replay_seq_cor, variable = "mean_slope"))
  #### Figure 3c
  data = dt_replay_seq_cor
  variable = "mean_slope"
  plot_stat = seq_test_period(data = data, variable = variable)

  # average across participants for every speed at every TR:
  plot_data = data %>%
    setDT(.) %>%
    .[, by = .(participant, period_short), .(
      mean_variable = mean(get(variable)))] %>%
    filter(period_short != "excluded")

  subset(plot_data) %>%
    write.csv(., file = file.path(path_sourcedata, sprintf("source_data_figure_3c_%s.csv", condition)),
              row.names = FALSE)

  # plot average correlation or betas for each speed condition and time period:
  plot = ggplot(data = plot_data, aes(
    x = fct_rev(as.factor(period_short)), y = as.numeric(mean_variable))) +
    geom_bar(stat = "summary", fun = "mean", width = 0.9, show.legend = TRUE) +
    geom_dotplot(binaxis = "y", stackdir = "center", stackratio = 0.5, alpha = 0.2,
                 binwidth = 0.01 * 0.1, show.legend = FALSE) +
    geom_errorbar(stat = "summary", fun.data = "mean_se", width = 0.0, color = "black") +
    geom_text(data = plot_stat, aes(
      x = fct_rev(as.factor(period_short)), y = round_updown(as.numeric(mean_variable), 0.6 * 0.1),
      label = paste0("d=", sprintf("%.2f", cohens_d), significance)), size = 3.3, show.legend = FALSE,
              color = subset(plot_stat)$color) +
    xlab("Period") +
    ylab("Regression slope") +
    scale_fill_viridis(name = "Speed (ms)", discrete = TRUE, option = "cividis") +
    theme(panel.border = element_blank(), axis.line = element_line()) +
    theme(axis.line = element_line(colour = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank()) +
    theme(axis.ticks.x = element_line(color = "white"),
          axis.line.x = element_line(color = "white")) +
    theme(legend.position = "top", legend.direction = "horizontal", legend.box = "vertical",
          legend.justification = "center", legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
          legend.box.margin = margin(t = 0, r = 0, b = -5, l = 0)) +
    theme(panel.spacing = unit(0, "lines"), strip.background = element_blank(),
          strip.placement = "outside", strip.text = element_blank())
  plot
  # save the plot figure and file
  ggsave(filename = sprintf("fmrireplay_plot_decoding_periods_slopes_%s.pdf", condition),
         plot = plot, device = cairo_pdf, path = path_figures, scale = 1,
         dpi = "retina", width = 5, height = 4)
}


```